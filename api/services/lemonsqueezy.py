import requests
from django.conf import settings
import logging
import hmac
import hashlib

logger = logging.getLogger(__name__)

class LemonSqueezyService:
    BASE_URL = "https://api.lemonsqueezy.com/v1"

    @staticmethod
    def get_headers():
        return {
            "Accept": "application/vnd.api+json",
            "Content-Type": "application/vnd.api+json",
            "Authorization": f"Bearer {settings.LEMONSQUEEZY_API_KEY}"
        }

    @staticmethod
    def create_checkout(user, variant_id, redirect_url=None):
        """
        Create a checkout session for a specific variant.
        """
        url = f"{LemonSqueezyService.BASE_URL}/checkouts"
        
        # Prepare custom data
        custom_data = {
            "user_id": str(user.id)
        }
        
        # Construct payload compliant with JSON:API spec
        attributes = {
            "checkout_data": {
                "email": user.email,
                "name": user.get_full_name() or user.username,
                "custom": custom_data
            }
        }

        # If redirect_url is provided, try to pass it via product_options -> redirect_url
        # Note: As of latest API, this might be in 'checkout_options' or require store config. 
        # But commonly 'product_options' -> 'redirect_url' works for specific overrides if allowed.
        if redirect_url:
            attributes["product_options"] = {
                "redirect_url": redirect_url
            }

        payload = {
            "data": {
                "type": "checkouts",
                "attributes": attributes,
                "relationships": {
                    "store": {
                        "data": {
                            "type": "stores",
                            "id": str(settings.LEMONSQUEEZY_STORE_ID)
                        }
                    },
                    "variant": {
                        "data": {
                            "type": "variants",
                            "id": str(variant_id)
                        }
                    }
                }
            }
        }

        try:
            response = requests.post(url, json=payload, headers=LemonSqueezyService.get_headers())
            response.raise_for_status()
            data = response.json()
            return data['data']['attributes']['url']
        except requests.exceptions.RequestException as e:
            logger.error(f"Lemon Squeezy Checkout Creation Failed: {e}")
            if e.response:
                logger.error(f"Response: {e.response.text}")
            raise

    @staticmethod
    def get_customer_portal_url(customer_id):
        """
        Get a link to the customer portal. 
        Lemon Squeezy Customer Portal is actually autogenerated link usually found in subscription object
        or via specific endpoint `customers/{id}` which returns `attributes.urls.customer_portal`.
        """
        url = f"{LemonSqueezyService.BASE_URL}/customers/{customer_id}"
        try:
            response = requests.get(url, headers=LemonSqueezyService.get_headers())
            response.raise_for_status()
            data = response.json()
            return data['data']['attributes']['urls']['customer_portal']
        except requests.exceptions.RequestException as e:
            logger.error(f"Failed to get portal URL: {e}")
            return None

    @staticmethod
    def verify_webhook(request):
        """
        Verify the X-Signature header.
        """
        secret = settings.LEMONSQUEEZY_WEBHOOK_SECRET
        if not secret:
            return False
            
        signature = request.META.get('HTTP_X_SIGNATURE')
        if not signature:
            return False

        # Compute HMAC
        # Ensure body is raw bytes
        body = request.body
        digest = hmac.new(secret.encode('utf-8'), body, hashlib.sha256).hexdigest()
        
        return hmac.compare_digest(digest, signature)

    @staticmethod
    def get_subscription(subscription_id):
        """
        Fetch subscription details from Lemon Squeezy.
        """
        url = f"{LemonSqueezyService.BASE_URL}/subscriptions/{subscription_id}"
        try:
            response = requests.get(url, headers=LemonSqueezyService.get_headers())
            response.raise_for_status()
            data = response.json()
            return data.get('data')
        except requests.exceptions.RequestException as e:
            logger.error(f"Failed to get subscription: {e}")
            return None

    @staticmethod
    def get_subscription_invoices(subscription_id):
        """
        Fetch invoices for a subscription.
        """
        url = f"{LemonSqueezyService.BASE_URL}/subscription-invoices"
        params = {
            "filter[subscription_id]": subscription_id,
            "page[size]": 10,
        }
        try:
            response = requests.get(url, params=params, headers=LemonSqueezyService.get_headers())
            response.raise_for_status()
            data = response.json()
            return data.get('data', [])
        except requests.exceptions.RequestException as e:
            logger.error(f"Failed to get invoices: {e}")
            return []

    @staticmethod
    def get_subscription_by_email(email):
        """
        Fallback: Find active subscription by user email.
        """
        url = f"{LemonSqueezyService.BASE_URL}/subscriptions"
        params = {
            "filter[store_id]": settings.LEMONSQUEEZY_STORE_ID,
            "filter[user_email]": email,
            "page[size]": 10
        }
        try:
            response = requests.get(url, params=params, headers=LemonSqueezyService.get_headers())
            response.raise_for_status()
            data = response.json()
            items = data.get('data', [])
            
            if not items:
                return None
                
            # Sort by created_at desc manually
            items.sort(key=lambda x: x.get('attributes', {}).get('created_at', ''), reverse=True)
            
            return items[0] # Return the most recent one
        except requests.exceptions.RequestException as e:
            logger.error(f"Failed to find subscription by email: {e}")
            return None
